703. Kth Largest Element in a Stream
思考順に書いていく。
step1.　pass
```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.nums = nums

    def add(self, val: int) -> int:
        self.nums.append(val)
        if self.nums == None:
            return None
        self.nums.sort(reverse=True)
        return self.nums[self.k - 1]
```
通ったが、1834msでかなり遅い。。。
最初関数を跨いだメンバの引用の仕方とsort関数の使い方を忘れていてpythonのドキュメントを読み確認した。
(https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables)
(https://docs.python.org/3/library/stdtypes.html#list.sort)

最初与えられた値をリストに追加し、降順にソートした上でk番目の値を吐き出した。
リストも値も存在しない場合はNoneを返すようにした。

こんなに遅いのはおそらくpythonのsortメソッドのせいかな？と思い調べた。
(https://www.naukri.com/code360/library/difference-between-sort-and-sorted-in-python)
>he sort() function compares the first two elements of the list and swaps them if they are not in order. It then compares the next element with the first element, switches them if necessary, and moves on to the next element until the entire input list is sorted.

>O(nlog(n)) : The time complexity of sort() function in Python is O(n log n) on average, and in the worst case, where n is the number of elements in the list to be sorted. This is because sort() use the timsort algorithm, which has this time complexity.

timesortは挿入ソートとマージソートのハイブリッド
(https://en.wikipedia.org/wiki/Timsort)

O(nlog(n))なら悪くなさそうだけど何でこんなに遅いんだろう。。。

他の人のコードも見てみる。
(https://github.com/Fuminiton/LeetCode/pull/8)
heap系の関数あったんだなー
（https://github.com/katataku/leetcode/pull/8）
あーkが負の場合を想定して弾くコードを書いた方がいいな。

ヒープを用いて解いてみる。
（https://docs.python.org/ja/3.13/library/heapq.html）
step2
```python
class KthLargest:
    import heapq

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        if self.k <= 0:
            return print("The value of k is Error!")
        self.nums = nums
        heapify(self.nums)

    def add(self, val: int) -> int:
        heappush(self.nums,val)
        if self.nums == None:
            return None
        while len(self.nums) > self.k:
            heappop(self.nums)
        return self.nums[0]
```
初めてheapqを使ったので手間取った。
今回は20ms
ヒープの方がstep1より遅そうなイメージあったけどかなり早いことに驚いた、
なんでこんなに早いの？
heapqのcpythonのライブラリを読んだ。
（https://github.com/python/cpython/blob/3.8/Lib/heapq.py）
```python
def heappush(heap, item):
    """Push item onto heap, maintaining the heap invariant."""
    heap.append(item)
    _siftdown(heap, 0, len(heap)-1)

def heappop(heap):
    """Pop the smallest item off the heap, maintaining the heap invariant."""
    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup(heap, 0)
        return returnitem
    return lastelt

def _siftdown(heap, startpos, pos):
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos > startpos:
        parentpos = (pos - 1) >> 1
        parent = heap[parentpos]
        if newitem < parent:
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem

def _siftup(heap, pos):
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]
    # Bubble up the smaller child until hitting a leaf.
    childpos = 2*pos + 1    # leftmost child position
    while childpos < endpos:
        # Set childpos to index of smaller child.
        rightpos = childpos + 1
        if rightpos < endpos and not heap[childpos] < heap[rightpos]:
            childpos = rightpos
        # Move the smaller child up.
        heap[pos] = heap[childpos]
        pos = childpos
        childpos = 2*pos + 1
    # The leaf at pos is empty now.  Put newitem there, and bubble it up
    # to its final resting place (by sifting its parents down).
    heap[pos] = newitem
    _siftdown(heap, startpos, pos)
```
ざっと読んだ。
（https://stackoverflow.com/questions/38806202/whats-the-time-complexity-of-functions-in-heapq-library）
ここまで読んでみたが、なぜstep1よりstep2がこんなに早いのか分からない。。。
どなたか分かる方がいればご教授お願いします

step3
1回目 1分56秒
2回目 1分31秒
3回目 1分57秒
```python
class KthLargest:
    import heapq

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        if k <= 0:
            return print("The value of k is Error")
        self.nums = nums
        heapify(self.nums)

    def add(self, val: int) -> int:
        heappush(self.nums,val)
        if self.nums == None:
            return None
        while len(self.nums) > self.k:
            heappop(self.nums)
        return self.nums[0]
```
