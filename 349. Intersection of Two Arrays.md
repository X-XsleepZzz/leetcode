349. Intersection of Two Arrays

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

---

step1
```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set_nums1 = set(nums1)
        set_nums2 = set(nums2)

        return list(set_nums1 & set_nums2)
```
nums1.lengthの最大値をn, nums2.lengthの最大値をmとする。  
時間計算量: set作成でO(n)とO(m)かかり、インターセクションでO(min(len(n), len(m)))平均計算量はO(n + m)。ハッシュ衝突で最悪計算量はsetのインターセクションはO(n * m)となる。(https://wiki.python.org/moin/TimeComplexity)
空間計算量: setは辞書と同様に内部でハッシュテーブルを使っているのでO(n + m)。結果のリストはmin(O(n), O(m))。  

> Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.  
(https://docs.python.org/3/glossary.html)

全ての要素がハッシュ衝突しないと最悪計算量にならないので、基本的にはインターセクションの時間計算量は平均計算量のO(n + m)と押さえておけばいいかな。  
setで入れた時点で重複は消えるので注意。今回はユニークであることを指定されているので構わないが。  

以下はCPythonのsetの積集合の内部メカニズム抜粋(https://github.com/python/cpython/blob/main/Objects/setobject.c)
```py
        if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {
            tmp = (PyObject *)so;
            so = (PySetObject *)other;
            other = tmp;

        while (set_next((PySetObject *)other, &pos, &entry)) {
            key = entry->key;
            hash = entry->hash;
            Py_INCREF(key);
            rv = set_contains_entry(so, key, hash);
            if (rv < 0) {
                Py_DECREF(result);
                Py_DECREF(key);
                return NULL;
            }
            if (rv) {
                if (set_add_entry(result, key, hash)) {
                    Py_DECREF(result);
                    Py_DECREF(key);
                    return NULL;
                }
            }
            Py_DECREF(key);
        }
        return (PyObject *)result;
    }
```
1. 集合の要素が少ない方を選ぶ
2. 小さい集合の要素を全て走査して、それぞれが大きい方の集合に含まれているかチェック。x in B的な
3. これはハッシュ検索なので1要素あたりO(1)。
だから時間計算量は全体で見ればO(min(m,n))になる。

---
(https://github.com/ksaito0629/leetcode_arai60/pull/12/changes)
を読んだ。
setの解法のほうがシンプルで良さそうだが、空間計算量を少しでも小さくしたいならksaito0629さんのstep3良いかも。  
入力ない場合は空のリスト返して処理してるのか。エッジケースのことも考えてるのは丁寧。  

勉強としてstep2以降は空間計算量を抑えるやり方で書く。

step2  
```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if not nums1 or not nums2:
            return []

        nums1.sort()
        nums2.sort()

        result_list = []

        i, j = 0, 0

        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                if not result_list or result_list[-1] != nums1[i]:
                    result_list.append(nums1[i])
                i += 1
                j += 1
        return result_list

```
時間計算量: .sort()だけでO(nlogn + mlogm)、走査のところでO(n + m)、よって全体でO(nlogn + mlogm)
空間計算量: 追加で用意したresult_listだけなのでO(1)

空間計算量を削減するために、.sorted()ではなく.sort()を使った。.sorted()では新しいリストを作成し直すため。  　
ただ、.sort()は破壊的変更なので引数のリストを勝手に変えて良いのか怖い。  
面接だったら、引数のリスト破壊していいか聞いたほうがいいのかな。  

これなら重複を許してインターセクションを吐き出せという問題になっても対応できるが、ダブルポインタってあまりpythonらしくない気もする。  

```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if not nums1 or not nums2:
            return []

        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1

        small_group = set(nums1)
        result_list = []

        for num in nums2:
            if num in small_group:
                result_list.append(num)
                small_group.remove(num)
        return result_list
```
時間計算量: ハッシュと走査でO(n + m)  
空間計算量: 小さい方のリストだけをハッシュにするので、O(min(n,m))  
辞書やsetなどのハッシュテーブルが内部のデータ構造になっているものは引数に入れたものと同じ大きさのものを吐き出すから。  
setを使ってる分、こっちのほうがpythonっぽい感じはする。  
こっちも重複ありの場合にも対応できる。　　

どっちでstep3に行くか迷ったけど、ハッシュ1つだけ使うやり方でやる。

step3 3回連続pass

```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if not nums1 or not nums2:
            return []

        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1

        small_group = set(nums1)
        result_list = []

        for num in nums2:
            if num in small_group:
                result_list.append(num)
                small_group.remove(num)
        return result_list
```


